$date
	Thu Feb 20 17:47:36 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module reverse_tb $end
$var wire 16 ! reverse [15:0] $end
$var wire 1 " Done $end
$var reg 1 # clk $end
$var reg 1 $ rst $end
$var reg 1 % start $end
$var reg 16 & x [15:0] $end
$scope module uut $end
$var wire 1 # clk $end
$var wire 1 $ rst $end
$var wire 1 % start $end
$var wire 16 ' x [15:0] $end
$var wire 1 ( x_eq $end
$var wire 1 ) st $end
$var wire 16 * reverse [15:0] $end
$var wire 1 + ld_x $end
$var wire 1 , ld_re $end
$var wire 1 - ld_out $end
$var wire 1 " Done $end
$scope module controller $end
$var wire 1 # clk $end
$var wire 1 $ rst $end
$var wire 1 % start $end
$var wire 1 ( x_eq $end
$var parameter 3 . COMPARE $end
$var parameter 3 / DONE $end
$var parameter 3 0 IDLE $end
$var parameter 3 1 LOAD $end
$var parameter 3 2 NEXT $end
$var reg 1 " Done $end
$var reg 1 - ld_out $end
$var reg 1 , ld_re $end
$var reg 1 + ld_x $end
$var reg 3 3 next_state [2:0] $end
$var reg 1 ) st $end
$var reg 3 4 state [2:0] $end
$upscope $end
$scope module datapath $end
$var wire 1 # clk $end
$var wire 1 - ld_out $end
$var wire 1 , ld_re $end
$var wire 1 + ld_x $end
$var wire 1 $ rst $end
$var wire 1 ) st $end
$var wire 16 5 x [15:0] $end
$var wire 16 6 x_src [15:0] $end
$var wire 16 7 x_out [15:0] $end
$var wire 16 8 x_mul [15:0] $end
$var wire 16 9 x_mod [15:0] $end
$var wire 1 ( x_eq $end
$var wire 16 : x_div [15:0] $end
$var wire 16 ; x_add [15:0] $end
$var wire 16 < reverse [15:0] $end
$var wire 16 = re_src [15:0] $end
$var wire 16 > re [15:0] $end
$scope module MuxRE $end
$var wire 16 ? a [15:0] $end
$var wire 1 ) sel $end
$var wire 16 @ b [15:0] $end
$var reg 16 A y [15:0] $end
$upscope $end
$scope module MuxX $end
$var wire 16 B a [15:0] $end
$var wire 1 ) sel $end
$var wire 16 C b [15:0] $end
$var reg 16 D y [15:0] $end
$upscope $end
$scope module add $end
$var wire 16 E b [15:0] $end
$var wire 16 F a [15:0] $end
$var reg 16 G y [15:0] $end
$upscope $end
$scope module comp $end
$var wire 16 H a [15:0] $end
$var wire 16 I b [15:0] $end
$var reg 1 ( y $end
$upscope $end
$scope module div $end
$var wire 16 J b [15:0] $end
$var wire 16 K a [15:0] $end
$var reg 16 L y [15:0] $end
$upscope $end
$scope module mod $end
$var wire 16 M b [15:0] $end
$var wire 16 N a [15:0] $end
$var reg 16 O y [15:0] $end
$upscope $end
$scope module mul $end
$var wire 16 P b [15:0] $end
$var wire 16 Q a [15:0] $end
$var reg 16 R y [15:0] $end
$upscope $end
$scope module regO $end
$var wire 1 # clk $end
$var wire 1 - ld $end
$var wire 1 $ rst $end
$var wire 16 S d [15:0] $end
$var reg 16 T q [15:0] $end
$upscope $end
$scope module regRE $end
$var wire 1 # clk $end
$var wire 16 U d [15:0] $end
$var wire 1 , ld $end
$var wire 1 $ rst $end
$var reg 16 V q [15:0] $end
$upscope $end
$scope module regX $end
$var wire 1 # clk $end
$var wire 16 W d [15:0] $end
$var wire 1 + ld $end
$var wire 1 $ rst $end
$var reg 16 X q [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b11 2
b1 1
b0 0
b100 /
b10 .
$end
#0
$dumpvars
b0 X
bx W
b0 V
b0 U
b0 T
b0 S
b0 R
b0 Q
b1010 P
b0 O
b0 N
b1010 M
b0 L
b0 K
b1010 J
b0 I
b0 H
b0 G
b0 F
b0 E
bx D
b0 C
bx B
b0 A
b0 @
b0 ?
b0 >
b0 =
b0 <
b0 ;
b0 :
b0 9
b0 8
b0 7
bx 6
bx 5
b0 4
b0 3
0-
1,
1+
b0 *
1)
1(
bx '
bx &
0%
1$
0#
x"
b0 !
$end
#5
bx ;
bx @
bx G
0(
bx :
bx C
bx L
bx 9
bx E
bx O
bx 7
bx I
bx K
bx N
bx X
b1 3
1)
1,
1+
b1001011 6
b1001011 D
b1001011 W
1%
b1001011 &
b1001011 '
b1001011 5
b1001011 B
0$
1#
#10
0#
#15
b101 ;
b101 @
b101 G
b111 :
b111 C
b111 L
b101 9
b101 E
b101 O
b1001011 7
b1001011 I
b1001011 K
b1001011 N
b1001011 X
b101 =
b101 A
b101 U
b111 6
b111 D
b111 W
b10 3
0)
1,
1+
b1 4
1#
#20
0#
#25
b111001 =
b111001 A
b111001 U
b0 6
b0 D
b0 W
b111001 ;
b111001 @
b111001 G
b110010 8
b110010 F
b110010 R
b0 :
b0 C
b0 L
b111 9
b111 E
b111 O
b101 >
b101 Q
b101 S
b101 V
b111 7
b111 I
b111 K
b111 N
b111 X
b11 3
0,
0+
b10 4
1#
#30
0#
#35
b1 3
b11 4
1#
#40
0#
#45
b10 3
1,
1+
b1 4
1#
#50
0#
#55
b1000111010 =
b1000111010 A
b1000111010 U
b1000111010 ;
b1000111010 @
b1000111010 G
1(
b0 9
b0 E
b0 O
b1000111010 8
b1000111010 F
b1000111010 R
b0 7
b0 I
b0 K
b0 N
b0 X
b111001 >
b111001 Q
b111001 S
b111001 V
b10 4
b100 3
0,
0+
1#
0%
#60
0#
#65
b0 3
1"
1-
b100 4
1#
#70
0#
#75
b111001 !
b111001 *
b111001 <
b111001 T
b0 =
b0 A
b0 U
b1001011 6
b1001011 D
b1001011 W
1,
1+
1)
0-
b0 4
1#
#80
0#
#85
1)
1,
1+
b101 ;
b101 @
b101 G
b0 8
b0 F
b0 R
0(
b111 :
b111 C
b111 L
b101 9
b101 E
b101 O
b0 >
b0 Q
b0 S
b0 V
b1001011 7
b1001011 I
b1001011 K
b1001011 N
b1001011 X
1#
